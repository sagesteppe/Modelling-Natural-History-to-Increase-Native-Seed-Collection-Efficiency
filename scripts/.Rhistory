# We generate the requested number of points, and then intersect them with
# the STZ to determine which STZ they are associated with. After extracting
# the aridity values from the raster, we can then determine which zones are more
# arid than others.
pts <- sf::st_sample(x, size = n) |>
sf::st_as_sf() |>
sf::st_transform(terra::crs(r))
pts <- sf::st_intersection(pts, x) |>
sf::st_transform(terra::crs(r))
pts <- terra::extract(r, pts, bind = TRUE, na.rm = TRUE, xy = TRUE) |>
sf::st_as_sf() |>
# ensure that no points are replicated by virtue of being in the same raster cell.
dplyr::distinct(x, y, .keep_all = TRUE) |>
dplyr::select(-x, -y) |>
# Stored as integer in file, has 4 decimals places.
dplyr::mutate(GAI = GAI/10000)
# Here we simple determine an order of aridity to each group based on it's
# median value of aridity. We will begin to create an output object for curious
# users who may want to better understand the sample size for each group. #
ZoneOrder <- pts |> # using the median, create an order for each seed zone
dplyr::group_by(!!SeedZone) |> # more arid areas have a lower order.
sf::st_drop_geometry() |>
dplyr::summarise(
MedianGAI = stats::median(GAI),
n = dplyr::n()
) |>
dplyr::arrange(MedianGAI) |>
dplyr::mutate(
SuggestedOrder = 1:dplyr::n(), .after = 1,
!!SeedZone := as.numeric(!!SeedZone),
Zones_fct = factor(!!SeedZone, levels = 1:dplyr::n())
)
# The seed zones, ordered by median aridity index, are now applied to the original
# random points we extracted raster values too. This will allow for easy comparisons
# of the different STZs to one another, i.e. we can order the groups in a plot.
pts <- dplyr::mutate(pts, !!SeedZone := factor(!!SeedZone, levels = ZoneOrder$Zones_fct))
# some products have many zones proposed, RColorBrewer will be hoity-toity if the
# number of colors requested from it exceeds it's recommended number of colors.
# this is associated with us essentially transforming a truly continuous color ramp
# to a discrete one for visualizing groups in the plots below - not a suggested
# practice for data vis, but our groups are now cut from an aridity gradient so...
getPalette = grDevices::colorRampPalette(
RColorBrewer::brewer.pal(
9, "RdYlGn")
)
# create a simple plot to show the analysts how the zones were ordered, and whether
# there was good evidence of a difference between any of them in the first place!
p <- ggpubr::ggboxplot(
pts,
x = "zone",
y = "GAI",
notch = TRUE,
color = "zone",
palette = getPalette(length(levels(pts$zone))),
outlier.alpha = 0.4
) +
# Add global p-value, unfortunately we cannot change from alpha at 0.05
# i would like to bump it to 0.9 - a 'compromise' between academia and the
# alpha 0.2 of land management.
ggpubr::stat_compare_means(
method = "kruskal",
label.y = 0.01,
label.x = 1.5,
) +
# determine which groups have strong evidence of have different central
# tendencies, we use the *** notation here, which is a compromise because
# so many p-values become a rounding mess, and no one wants sci notation on plots
ggpubr::stat_compare_means(
label = "p.signif",
method = "t.test",
ref.group = ".all."
) +
ggplot2::labs( # specify what we are up to.
title = 'Empirical STZs ordered by Global Aridity Index (GAI)',
y = 'Global Aridity Index',
x = 'Zone'
) +
# nasty big legend associated with the groups is created, unnecessary for boxplot
# and takes up a lot of real estate.
ggplot2::guides(color="none") +
ggplot2::theme(
axis.line.y = ggplot2::element_blank(),
axis.line.x = ggplot2::element_blank())
# return the same input item, but with the original zones overwritten.
rcl <- dplyr::left_join(x, dplyr::select(ZoneOrder, !!SeedZone, SuggestedOrder)) |>
dplyr::select(-!!SeedZone, !!SeedZone := SuggestedOrder)
return(
list(
Reclassified = rcl,
Summary = ZoneOrder,
Plot = p,
)
)
}
orderZones(acth7, SeedZone = zone)
acth7 <- sf::st_read(file.path(
system.file(package="eSTZwritR"), "extdata", 'ACTH7.gpkg')
)
orderZones(acth7, SeedZone = zone)
acth7 <- sf::st_read(file.path(
system.file(package="eSTZwritR"), "extdata", 'ACTH7.gpkg')
) |>
sf::st_make_valid()
orderZones(acth7, SeedZone = zone)
#' cont <- terra::rast(
#'  file.path(
#'     system.file(package="eSTZwritR"), "extdata", 'GAI-cont.tif')
#' )
#' plot(cont)
#' @returns A list containing three components, 'Reclassified' the shapefile which
#' was submitted, with the #' seedzone values over written by the ones resulting from the function.
#' 'Summary' a dataframe containing the original zones, and final zones, as well as the calculated median and the number of samples used to calculate the median.
#' 'Plot' a ggpubr boxplot of the results of a kruskal-wallis test amongst seed zones.
#' @export
orderZones <- function(x, SeedZone, n, rasta, ...){
SeedZone <- dplyr::enquo(SeedZone)
if(missing(n)){n <- 2500}
if(missing(rasta)){rasta <- 'cont'} # if the user supplied a raster use that instead.
if(typeof(rasta)!='S4'){
r <- terra::rast(
file.path(
system.file(package="eSTZwritR"),  "extdata",
paste0('GAI-', rasta, '.tif')
)
)
} else {r <- rasta}
names(r) <- 'GAI' # ensure naming of raster is correct.
# We generate the requested number of points, and then intersect them with
# the STZ to determine which STZ they are associated with. After extracting
# the aridity values from the raster, we can then determine which zones are more
# arid than others.
pts <- sf::st_sample(x, size = n) |>
sf::st_as_sf() |>
sf::st_transform(terra::crs(r))
pts <- sf::st_intersection(pts, x) |>
sf::st_transform(terra::crs(r))
pts <- terra::extract(r, pts, bind = TRUE, na.rm = TRUE, xy = TRUE) |>
sf::st_as_sf() |>
# ensure that no points are replicated by virtue of being in the same raster cell.
dplyr::distinct(x, y, .keep_all = TRUE) |>
dplyr::select(-x, -y) |>
# Stored as integer in file, has 4 decimals places.
dplyr::mutate(GAI = GAI/10000)
# Here we simple determine an order of aridity to each group based on it's
# median value of aridity. We will begin to create an output object for curious
# users who may want to better understand the sample size for each group. #
ZoneOrder <- pts |> # using the median, create an order for each seed zone
dplyr::group_by(!!SeedZone) |> # more arid areas have a lower order.
sf::st_drop_geometry() |>
dplyr::summarise(
MedianGAI = stats::median(GAI),
n = dplyr::n()
) |>
dplyr::arrange(MedianGAI) |>
dplyr::mutate(
SuggestedOrder = 1:dplyr::n(), .after = 1,
!!SeedZone := as.numeric(!!SeedZone),
Zones_fct = factor(!!SeedZone, levels = 1:dplyr::n())
)
# The seed zones, ordered by median aridity index, are now applied to the original
# random points we extracted raster values too. This will allow for easy comparisons
# of the different STZs to one another, i.e. we can order the groups in a plot.
pts <- dplyr::mutate(pts, !!SeedZone := factor(!!SeedZone, levels = ZoneOrder$Zones_fct))
# some products have many zones proposed, RColorBrewer will be hoity-toity if the
# number of colors requested from it exceeds it's recommended number of colors.
# this is associated with us essentially transforming a truly continuous color ramp
# to a discrete one for visualizing groups in the plots below - not a suggested
# practice for data vis, but our groups are now cut from an aridity gradient so...
getPalette = grDevices::colorRampPalette(
RColorBrewer::brewer.pal(
9, "RdYlGn")
)
# create a simple plot to show the analysts how the zones were ordered, and whether
# there was good evidence of a difference between any of them in the first place!
p <- ggpubr::ggboxplot(
pts,
x = "zone",
y = "GAI",
notch = TRUE,
color = "zone",
palette = getPalette(length(levels(pts$zone))),
outlier.alpha = 0.4
) +
# Add global p-value, unfortunately we cannot change from alpha at 0.05
# i would like to bump it to 0.9 - a 'compromise' between academia and the
# alpha 0.2 of land management.
ggpubr::stat_compare_means(
method = "kruskal",
label.y = 0.01,
label.x = 1.5,
) +
# determine which groups have strong evidence of have different central
# tendencies, we use the *** notation here, which is a compromise because
# so many p-values become a rounding mess, and no one wants sci notation on plots
ggpubr::stat_compare_means(
label = "p.signif",
method = "t.test",
ref.group = ".all."
) +
ggplot2::labs( # specify what we are up to.
title = 'Empirical STZs ordered by Global Aridity Index (GAI)',
y = 'Global Aridity Index',
x = 'Zone'
) +
# nasty big legend associated with the groups is created, unnecessary for boxplot
# and takes up a lot of real estate.
ggplot2::guides(color="none") +
ggplot2::theme(
axis.line.y = ggplot2::element_blank(),
axis.line.x = ggplot2::element_blank())
# return the same input item, but with the original zones overwritten.
rcl <- dplyr::left_join(x, dplyr::select(ZoneOrder, !!SeedZone, SuggestedOrder)) |>
dplyr::select(-!!SeedZone, !!SeedZone := SuggestedOrder)
return(
list(
Reclassified = rcl,
Summary = ZoneOrder,
Plot = p
)
)
}
orderZones(acth7, SeedZone = zone, n = 1000)
zoneOrder_suggestions <- orderZones(acth7, SeedZone = zone, n = 1000)
zoneOrder_suggestions
zoneOrder_suggestions <- orderZones(acth7, SeedZone = zone, n = 1000)
gc()
#' cont <- terra::rast(
#'  file.path(
#'     system.file(package="eSTZwritR"), "extdata", 'GAI-cont.tif')
#' )
#' plot(cont)
#' @returns A list containing three components, 'Reclassified' the shapefile which
#' was submitted, with the #' seedzone values over written by the ones resulting from the function.
#' 'Summary' a dataframe containing the original zones, and final zones, as well as the calculated median and the number of samples used to calculate the median.
#' 'Plot' a ggpubr boxplot of the results of a kruskal-wallis test amongst seed zones.
#' @export
orderZones <- function(x, SeedZone, n, rasta, ...){
SeedZone <- dplyr::enquo(SeedZone)
if(missing(n)){n <- 2500}
if(missing(rasta)){rasta <- 'cont'} # if the user supplied a raster use that instead.
if(typeof(rasta)!='S4'){
r <- terra::rast(
file.path(
system.file(package="eSTZwritR"),  "extdata",
paste0('GAI-', rasta, '.tif')
)
)
} else {r <- rasta}
names(r) <- 'GAI' # ensure naming of raster is correct.
# We generate the requested number of points, and then intersect them with
# the STZ to determine which STZ they are associated with. After extracting
# the aridity values from the raster, we can then determine which zones are more
# arid than others.
pts <- sf::st_sample(x, size = n) |>
sf::st_as_sf() |>
sf::st_transform(terra::crs(r))
pts <- sf::st_intersection(pts, x) |>
sf::st_transform(terra::crs(r))
pts <- terra::extract(r, pts, bind = TRUE, na.rm = TRUE, xy = TRUE) |>
sf::st_as_sf() |>
# ensure that no points are replicated by virtue of being in the same raster cell.
dplyr::distinct(x, y, .keep_all = TRUE) |>
dplyr::select(-x, -y) |>
# Stored as integer in file, has 4 decimals places.
dplyr::mutate(GAI = GAI/10000)
# Here we simple determine an order of aridity to each group based on it's
# median value of aridity. We will begin to create an output object for curious
# users who may want to better understand the sample size for each group. #
ZoneOrder <- pts |> # using the median, create an order for each seed zone
dplyr::group_by(!!SeedZone) |> # more arid areas have a lower order.
sf::st_drop_geometry() |>
dplyr::summarise(
MedianGAI = stats::median(GAI),
n = dplyr::n()
) |>
dplyr::arrange(MedianGAI) |>
dplyr::mutate(
SuggestedOrder = 1:dplyr::n(), .after = 1,
!!SeedZone := as.numeric(!!SeedZone),
Zones_fct = factor(!!SeedZone, levels = 1:dplyr::n())
)
# The seed zones, ordered by median aridity index, are now applied to the original
# random points we extracted raster values too. This will allow for easy comparisons
# of the different STZs to one another, i.e. we can order the groups in a plot.
pts <- dplyr::mutate(pts, !!SeedZone := factor(!!SeedZone, levels = ZoneOrder$Zones_fct))
# some products have many zones proposed, RColorBrewer will be hoity-toity if the
# number of colors requested from it exceeds it's recommended number of colors.
# this is associated with us essentially transforming a truly continuous color ramp
# to a discrete one for visualizing groups in the plots below - not a suggested
# practice for data vis, but our groups are now cut from an aridity gradient so...
getPalette = grDevices::colorRampPalette(
RColorBrewer::brewer.pal(
9, "RdYlGn")
)
# create a simple plot to show the analysts how the zones were ordered, and whether
# there was good evidence of a difference between any of them in the first place!
p <- ggpubr::ggboxplot(
pts,
x = "zone",
y = "GAI",
notch = TRUE,
color = "zone",
palette = getPalette(length(levels(pts$zone))),
outlier.alpha = 0.4
) +
# Add global p-value, unfortunately we cannot change from alpha at 0.05
# i would like to bump it to 0.9 - a 'compromise' between academia and the
# alpha 0.2 of land management.
ggpubr::stat_compare_means(
method = "kruskal",
label.y = 0.01,
label.x = 1.5,
) +
# determine which groups have strong evidence of have different central
# tendencies, we use the *** notation here, which is a compromise because
# so many p-values become a rounding mess, and no one wants sci notation on plots
ggpubr::stat_compare_means(
label = "p.signif",
method = "t.test",
ref.group = ".all."
) +
ggplot2::labs( # specify what we are up to.
title = 'Empirical STZs ordered by Global Aridity Index (GAI)',
y = 'Global Aridity Index',
x = 'Zone'
) +
# nasty big legend associated with the groups is created, unnecessary for boxplot
# and takes up a lot of real estate.
ggplot2::guides(color="none") +
ggplot2::theme(
axis.line.y = ggplot2::element_blank(),
axis.line.x = ggplot2::element_blank())
# return the same input item, but with the original zones overwritten.
rcl <- dplyr::left_join(
x,
dplyr::select(ZoneOrder, !!SeedZone, SuggestedOrder),
by = !!SeedZone) |>
dplyr::select(-!!SeedZone, !!SeedZone := SuggestedOrder)
return(
list(
Reclassified = rcl,
Summary = ZoneOrder,
Plot = p
)
)
}
acth7 <- sf::st_read(file.path(
system.file(package="eSTZwritR"), "extdata", 'ACTH7.gpkg')
) |>
sf::st_make_valid()
zoneOrder_suggestions <- orderZones(acth7, SeedZone = zone, n = 1000)
#' cont <- terra::rast(
#'  file.path(
#'     system.file(package="eSTZwritR"), "extdata", 'GAI-cont.tif')
#' )
#' plot(cont)
#' @returns A list containing three components, 'Reclassified' the shapefile which
#' was submitted, with the #' seedzone values over written by the ones resulting from the function.
#' 'Summary' a dataframe containing the original zones, and final zones, as well as the calculated median and the number of samples used to calculate the median.
#' 'Plot' a ggpubr boxplot of the results of a kruskal-wallis test amongst seed zones.
#' @export
orderZones <- function(x, SeedZone, n, rasta, ...){
SeedZone <- dplyr::enquo(SeedZone)
if(missing(n)){n <- 2500}
if(missing(rasta)){rasta <- 'cont'} # if the user supplied a raster use that instead.
if(typeof(rasta)!='S4'){
r <- terra::rast(
file.path(
system.file(package="eSTZwritR"),  "extdata",
paste0('GAI-', rasta, '.tif')
)
)
} else {r <- rasta}
names(r) <- 'GAI' # ensure naming of raster is correct.
# We generate the requested number of points, and then intersect them with
# the STZ to determine which STZ they are associated with. After extracting
# the aridity values from the raster, we can then determine which zones are more
# arid than others.
pts <- sf::st_sample(x, size = n) |>
sf::st_as_sf() |>
sf::st_transform(terra::crs(r))
pts <- sf::st_intersection(pts, x) |>
sf::st_transform(terra::crs(r))
pts <- terra::extract(r, pts, bind = TRUE, na.rm = TRUE, xy = TRUE) |>
sf::st_as_sf() |>
# ensure that no points are replicated by virtue of being in the same raster cell.
dplyr::distinct(x, y, .keep_all = TRUE) |>
dplyr::select(-x, -y) |>
# Stored as integer in file, has 4 decimals places.
dplyr::mutate(GAI = GAI/10000)
# Here we simple determine an order of aridity to each group based on it's
# median value of aridity. We will begin to create an output object for curious
# users who may want to better understand the sample size for each group. #
ZoneOrder <- pts |> # using the median, create an order for each seed zone
dplyr::group_by(!!SeedZone) |> # more arid areas have a lower order.
sf::st_drop_geometry() |>
dplyr::summarise(
MedianGAI = stats::median(GAI),
n = dplyr::n()
) |>
dplyr::arrange(MedianGAI) |>
dplyr::mutate(
SuggestedOrder = 1:dplyr::n(), .after = 1,
!!SeedZone := as.numeric(!!SeedZone),
Zones_fct = factor(!!SeedZone, levels = 1:dplyr::n())
)
# The seed zones, ordered by median aridity index, are now applied to the original
# random points we extracted raster values too. This will allow for easy comparisons
# of the different STZs to one another, i.e. we can order the groups in a plot.
pts <- dplyr::mutate(pts, !!SeedZone := factor(!!SeedZone, levels = ZoneOrder$Zones_fct))
# some products have many zones proposed, RColorBrewer will be hoity-toity if the
# number of colors requested from it exceeds it's recommended number of colors.
# this is associated with us essentially transforming a truly continuous color ramp
# to a discrete one for visualizing groups in the plots below - not a suggested
# practice for data vis, but our groups are now cut from an aridity gradient so...
getPalette = grDevices::colorRampPalette(
RColorBrewer::brewer.pal(
9, "RdYlGn")
)
# create a simple plot to show the analysts how the zones were ordered, and whether
# there was good evidence of a difference between any of them in the first place!
p <- ggpubr::ggboxplot(
pts,
x = "zone",
y = "GAI",
notch = TRUE,
color = "zone",
palette = getPalette(length(levels(pts$zone))),
outlier.alpha = 0.4
) +
# Add global p-value, unfortunately we cannot change from alpha at 0.05
# i would like to bump it to 0.9 - a 'compromise' between academia and the
# alpha 0.2 of land management.
ggpubr::stat_compare_means(
method = "kruskal",
label.y = 0.01,
label.x = 1.5,
) +
# determine which groups have strong evidence of have different central
# tendencies, we use the *** notation here, which is a compromise because
# so many p-values become a rounding mess, and no one wants sci notation on plots
ggpubr::stat_compare_means(
label = "p.signif",
method = "t.test",
ref.group = ".all."
) +
ggplot2::labs( # specify what we are up to.
title = 'Empirical STZs ordered by Global Aridity Index (GAI)',
y = 'Global Aridity Index',
x = 'Zone'
) +
# nasty big legend associated with the groups is created, unnecessary for boxplot
# and takes up a lot of real estate.
ggplot2::guides(color="none") +
ggplot2::theme(
axis.line.y = ggplot2::element_blank(),
axis.line.x = ggplot2::element_blank())
# return the same input item, but with the original zones overwritten.
rcl <- dplyr::left_join(
x,
dplyr::select(ZoneOrder, !!SeedZone, SuggestedOrder)) |>
dplyr::select(-!!SeedZone, !!SeedZone := SuggestedOrder)
return(
list(
Reclassified = rcl,
Summary = ZoneOrder,
Plot = p
)
)
}
acth7 <- sf::st_read(file.path(
system.file(package="eSTZwritR"), "extdata", 'ACTH7.gpkg')
) |>
sf::st_make_valid()
zoneOrder_suggestions <- orderZones(acth7, SeedZone = zone, n = 1000)
zoneOrder_suggestions
zoneOrder_suggestions$Plot
zoneOrder_suggestions$Summary
zoneOrder_suggestions$Reclassified
??ggboxplot
library(eSTZwritR)
acth7 <- sf::st_read(file.path(
system.file(package="eSTZwritR"), "extdata", 'ACTH7.gpkg')
)
mapmakR(acth7,
species = 'Eriocoma thurberiana',
save = TRUE,
portrait = TRUE,
ecoregions = TRUE,
cities = TRUE,
caption = 'Data from Johnson et al. 2017. https://doi.org/10.1016/j.rama.2017.01.004')
mapmakR(acth7,
species = 'Eriocoma thurberiana',
save = TRUE,
landscape = FALSE,
ecoregions = TRUE,
cities = TRUE,
caption = 'Data from Johnson et al. 2017. https://doi.org/10.1016/j.rama.2017.01.004')
setwd('/home/sagesteppe/Documents/assoRted/Benkendorf_NAC24_Talk/scripts')
results = rpubsUpload(
title='Modelling Natural History to Increase Native Seed Collection Efficiency - Space, Time, and Connectivity',
htmlFile='ModellingNaturalHistory.html',
method=getOption('rpubs.upload.method','auto'))
library(markdown)
results = rpubsUpload(
title='Modelling Natural History to Increase Native Seed Collection Efficiency - Space, Time, and Connectivity',
htmlFile='ModellingNaturalHistory.html',
method=getOption('rpubs.upload.method','auto'))
results
?rpubsUpload
View(results)
results[["error"]]
